// Code generated by protoc-gen-gogo. DO NOT EDIT.

package persistence

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	v1 "github.com/temporalio/tctl/api/enums/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NamespaceStorageMetadata struct {
	RegionalStorageMetadata map[string]*NamespaceStorageRegionalMetadata `protobuf:"bytes,1,rep,name=regional_storage_metadata,json=regionalStorageMetadata,proto3" json:"regional_storage_metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamespaceStorageMetadata) Reset()      { *m = NamespaceStorageMetadata{} }
func (*NamespaceStorageMetadata) ProtoMessage() {}
func (*NamespaceStorageMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_aea578fac0fed896, []int{0}
}
func (m *NamespaceStorageMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceStorageMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceStorageMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceStorageMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceStorageMetadata.Merge(m, src)
}
func (m *NamespaceStorageMetadata) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceStorageMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceStorageMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceStorageMetadata proto.InternalMessageInfo

func (m *NamespaceStorageMetadata) GetRegionalStorageMetadata() map[string]*NamespaceStorageRegionalMetadata {
	if m != nil {
		return m.RegionalStorageMetadata
	}
	return nil
}

type NamespaceStorageRegionalMetadata struct {
	// Provider of the storage object
	Provider v1.StorageProvider `protobuf:"varint,1,opt,name=provider,proto3,enum=temporal.saas.api.enums.v1.StorageProvider" json:"provider,omitempty"`
	// Types that are valid to be assigned to Metadata:
	//	*NamespaceStorageRegionalMetadata_AwsS3Metadata
	Metadata isNamespaceStorageRegionalMetadata_Metadata `protobuf_oneof:"metadata"`
}

func (m *NamespaceStorageRegionalMetadata) Reset()      { *m = NamespaceStorageRegionalMetadata{} }
func (*NamespaceStorageRegionalMetadata) ProtoMessage() {}
func (*NamespaceStorageRegionalMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_aea578fac0fed896, []int{1}
}
func (m *NamespaceStorageRegionalMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceStorageRegionalMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamespaceStorageRegionalMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamespaceStorageRegionalMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceStorageRegionalMetadata.Merge(m, src)
}
func (m *NamespaceStorageRegionalMetadata) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceStorageRegionalMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceStorageRegionalMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceStorageRegionalMetadata proto.InternalMessageInfo

type isNamespaceStorageRegionalMetadata_Metadata interface {
	isNamespaceStorageRegionalMetadata_Metadata()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NamespaceStorageRegionalMetadata_AwsS3Metadata struct {
	AwsS3Metadata *AWSS3Metadata `protobuf:"bytes,11,opt,name=aws_s3_metadata,json=awsS3Metadata,proto3,oneof" json:"aws_s3_metadata,omitempty"`
}

func (*NamespaceStorageRegionalMetadata_AwsS3Metadata) isNamespaceStorageRegionalMetadata_Metadata() {
}

func (m *NamespaceStorageRegionalMetadata) GetMetadata() isNamespaceStorageRegionalMetadata_Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *NamespaceStorageRegionalMetadata) GetProvider() v1.StorageProvider {
	if m != nil {
		return m.Provider
	}
	return v1.STORAGE_PROVIDER_UNSPECIFIED
}

func (m *NamespaceStorageRegionalMetadata) GetAwsS3Metadata() *AWSS3Metadata {
	if x, ok := m.GetMetadata().(*NamespaceStorageRegionalMetadata_AwsS3Metadata); ok {
		return x.AwsS3Metadata
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NamespaceStorageRegionalMetadata) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NamespaceStorageRegionalMetadata_AwsS3Metadata)(nil),
	}
}

type AWSS3Metadata struct {
	// Region is the object storage region based on provider
	Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Container is the bucket of the object
	Container string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	// Data access IAM ARN
	AssumeRoleArn string `protobuf:"bytes,3,opt,name=assume_role_arn,json=assumeRoleArn,proto3" json:"assume_role_arn,omitempty"`
}

func (m *AWSS3Metadata) Reset()      { *m = AWSS3Metadata{} }
func (*AWSS3Metadata) ProtoMessage() {}
func (*AWSS3Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_aea578fac0fed896, []int{2}
}
func (m *AWSS3Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSS3Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AWSS3Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AWSS3Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSS3Metadata.Merge(m, src)
}
func (m *AWSS3Metadata) XXX_Size() int {
	return m.Size()
}
func (m *AWSS3Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSS3Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_AWSS3Metadata proto.InternalMessageInfo

func (m *AWSS3Metadata) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *AWSS3Metadata) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *AWSS3Metadata) GetAssumeRoleArn() string {
	if m != nil {
		return m.AssumeRoleArn
	}
	return ""
}

func init() {
	proto.RegisterType((*NamespaceStorageMetadata)(nil), "temporal.saas.api.persistence.v1.NamespaceStorageMetadata")
	proto.RegisterMapType((map[string]*NamespaceStorageRegionalMetadata)(nil), "temporal.saas.api.persistence.v1.NamespaceStorageMetadata.RegionalStorageMetadataEntry")
	proto.RegisterType((*NamespaceStorageRegionalMetadata)(nil), "temporal.saas.api.persistence.v1.NamespaceStorageRegionalMetadata")
	proto.RegisterType((*AWSS3Metadata)(nil), "temporal.saas.api.persistence.v1.AWSS3Metadata")
}

func init() {
	proto.RegisterFile("temporal/saas/api/persistence/v1/history_tree.proto", fileDescriptor_aea578fac0fed896)
}

var fileDescriptor_aea578fac0fed896 = []byte{
	// 468 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xbf, 0x6e, 0x13, 0x41,
	0x10, 0xc6, 0x6f, 0x6d, 0x11, 0xc5, 0x6b, 0x99, 0xa0, 0x2d, 0xe0, 0x88, 0xa2, 0xd5, 0xc9, 0x05,
	0xb2, 0x84, 0xd8, 0x53, 0xec, 0x06, 0x41, 0x15, 0x4b, 0x08, 0x1a, 0x10, 0x3a, 0x17, 0x01, 0x9a,
	0xd3, 0xc4, 0x19, 0x39, 0x2b, 0xee, 0x6e, 0x4f, 0xbb, 0x6b, 0x07, 0x77, 0x3c, 0x01, 0x42, 0xe2,
	0x25, 0x78, 0x0d, 0x3a, 0x4a, 0x8b, 0x2a, 0x25, 0x3e, 0x37, 0x94, 0x79, 0x04, 0x74, 0xff, 0xe2,
	0x40, 0x02, 0x56, 0xba, 0xdb, 0xd9, 0xf9, 0x7e, 0xf3, 0xcd, 0xce, 0x0d, 0x1d, 0x58, 0x8c, 0x53,
	0xa5, 0x21, 0xf2, 0x0d, 0x80, 0xf1, 0x21, 0x95, 0x7e, 0x8a, 0xda, 0x48, 0x63, 0x31, 0x19, 0xa3,
	0x3f, 0xdb, 0xf7, 0x4f, 0xa4, 0xb1, 0x4a, 0xcf, 0x43, 0xab, 0x11, 0x45, 0xaa, 0x95, 0x55, 0xcc,
	0xab, 0x45, 0x22, 0x17, 0x09, 0x48, 0xa5, 0xb8, 0x24, 0x12, 0xb3, 0xfd, 0xdd, 0xde, 0x55, 0x2c,
	0x26, 0xd3, 0xd8, 0xe4, 0xc0, 0x1c, 0x07, 0x93, 0x8a, 0xd5, 0xfd, 0xd6, 0xa0, 0xee, 0x2b, 0x88,
	0xd1, 0xa4, 0x30, 0xc6, 0x51, 0x79, 0xf5, 0x12, 0x2d, 0x1c, 0x83, 0x05, 0xf6, 0x85, 0xd0, 0xfb,
	0x1a, 0x27, 0x52, 0x25, 0x10, 0x85, 0x95, 0x2e, 0x8c, 0xab, 0x5b, 0x97, 0x78, 0xcd, 0x5e, 0xbb,
	0x7f, 0x28, 0x36, 0xb9, 0x11, 0xff, 0xe2, 0x8b, 0xa0, 0x62, 0xff, 0x15, 0x7f, 0x96, 0x58, 0x3d,
	0x0f, 0xee, 0xe9, 0xeb, 0x6f, 0x77, 0x3f, 0x11, 0xba, 0xf7, 0x3f, 0x25, 0xbb, 0x43, 0x9b, 0xef,
	0x71, 0xee, 0x12, 0x8f, 0xf4, 0x5a, 0x41, 0xfe, 0xc9, 0xde, 0xd0, 0x5b, 0x33, 0x88, 0xa6, 0xe8,
	0x36, 0x3c, 0xd2, 0x6b, 0xf7, 0x87, 0x37, 0xf7, 0x5c, 0x17, 0xac, 0x2b, 0x05, 0x25, 0xf0, 0x49,
	0xe3, 0x31, 0xe9, 0xfe, 0x20, 0xd4, 0xdb, 0x94, 0xcf, 0x9e, 0xd3, 0xed, 0x54, 0xab, 0x99, 0x3c,
	0x46, 0x5d, 0x38, 0xbb, 0xdd, 0x7f, 0x78, 0x8d, 0x8b, 0x62, 0x4a, 0x79, 0xfd, 0x0a, 0xf3, 0xba,
	0x92, 0x04, 0x17, 0x62, 0xf6, 0x96, 0xee, 0xc0, 0xa9, 0x09, 0xcd, 0x60, 0x3d, 0x89, 0x76, 0xd1,
	0x95, 0xbf, 0xb9, 0xab, 0x83, 0xc3, 0xd1, 0x68, 0x50, 0x5b, 0x7a, 0xe1, 0x04, 0x1d, 0x38, 0x35,
	0xeb, 0xc0, 0x90, 0xd2, 0xed, 0x9a, 0xd9, 0x8d, 0x69, 0xe7, 0x8f, 0x6c, 0x76, 0x97, 0x6e, 0x95,
	0x13, 0xa9, 0x1e, 0xb6, 0x3a, 0xb1, 0x3d, 0xda, 0x1a, 0xab, 0xc4, 0x82, 0x4c, 0x50, 0x17, 0xef,
	0xdb, 0x0a, 0xd6, 0x01, 0xf6, 0x80, 0xee, 0x80, 0x31, 0xd3, 0x18, 0x43, 0xad, 0x22, 0x0c, 0x41,
	0x27, 0x6e, 0xb3, 0xc8, 0xe9, 0x94, 0xe1, 0x40, 0x45, 0x78, 0xa0, 0x93, 0xe1, 0x87, 0xc5, 0x92,
	0x3b, 0x67, 0x4b, 0xee, 0x9c, 0x2f, 0x39, 0xf9, 0x98, 0x71, 0xf2, 0x35, 0xe3, 0xe4, 0x7b, 0xc6,
	0xc9, 0x22, 0xe3, 0xe4, 0x67, 0xc6, 0xc9, 0xaf, 0x8c, 0x3b, 0xe7, 0x19, 0x27, 0x9f, 0x57, 0xdc,
	0x59, 0xac, 0xb8, 0x73, 0xb6, 0xe2, 0xce, 0xbb, 0xe1, 0x44, 0xda, 0x93, 0xe9, 0x91, 0x18, 0xab,
	0xd8, 0xaf, 0x9b, 0x97, 0xaa, 0xf8, 0xe9, 0x1f, 0x5d, 0xac, 0xc0, 0xd5, 0xa5, 0x7a, 0x7a, 0xe9,
	0x78, 0xb4, 0x55, 0x2c, 0xc2, 0xe0, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa8, 0xe3, 0x00, 0xf5,
	0x8b, 0x03, 0x00, 0x00,
}

func (this *NamespaceStorageMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceStorageMetadata)
	if !ok {
		that2, ok := that.(NamespaceStorageMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RegionalStorageMetadata) != len(that1.RegionalStorageMetadata) {
		return false
	}
	for i := range this.RegionalStorageMetadata {
		if !this.RegionalStorageMetadata[i].Equal(that1.RegionalStorageMetadata[i]) {
			return false
		}
	}
	return true
}
func (this *NamespaceStorageRegionalMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceStorageRegionalMetadata)
	if !ok {
		that2, ok := that.(NamespaceStorageRegionalMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if that1.Metadata == nil {
		if this.Metadata != nil {
			return false
		}
	} else if this.Metadata == nil {
		return false
	} else if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *NamespaceStorageRegionalMetadata_AwsS3Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceStorageRegionalMetadata_AwsS3Metadata)
	if !ok {
		that2, ok := that.(NamespaceStorageRegionalMetadata_AwsS3Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsS3Metadata.Equal(that1.AwsS3Metadata) {
		return false
	}
	return true
}
func (this *AWSS3Metadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSS3Metadata)
	if !ok {
		that2, ok := that.(AWSS3Metadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.AssumeRoleArn != that1.AssumeRoleArn {
		return false
	}
	return true
}
func (this *NamespaceStorageMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&persistence.NamespaceStorageMetadata{")
	keysForRegionalStorageMetadata := make([]string, 0, len(this.RegionalStorageMetadata))
	for k, _ := range this.RegionalStorageMetadata {
		keysForRegionalStorageMetadata = append(keysForRegionalStorageMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionalStorageMetadata)
	mapStringForRegionalStorageMetadata := "map[string]*NamespaceStorageRegionalMetadata{"
	for _, k := range keysForRegionalStorageMetadata {
		mapStringForRegionalStorageMetadata += fmt.Sprintf("%#v: %#v,", k, this.RegionalStorageMetadata[k])
	}
	mapStringForRegionalStorageMetadata += "}"
	if this.RegionalStorageMetadata != nil {
		s = append(s, "RegionalStorageMetadata: "+mapStringForRegionalStorageMetadata+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceStorageRegionalMetadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&persistence.NamespaceStorageRegionalMetadata{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	if this.Metadata != nil {
		s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceStorageRegionalMetadata_AwsS3Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&persistence.NamespaceStorageRegionalMetadata_AwsS3Metadata{` +
		`AwsS3Metadata:` + fmt.Sprintf("%#v", this.AwsS3Metadata) + `}`}, ", ")
	return s
}
func (this *AWSS3Metadata) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&persistence.AWSS3Metadata{")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "AssumeRoleArn: "+fmt.Sprintf("%#v", this.AssumeRoleArn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringHistoryTree(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NamespaceStorageMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceStorageMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceStorageMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegionalStorageMetadata) > 0 {
		for k := range m.RegionalStorageMetadata {
			v := m.RegionalStorageMetadata[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintHistoryTree(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintHistoryTree(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintHistoryTree(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceStorageRegionalMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceStorageRegionalMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceStorageRegionalMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size := m.Metadata.Size()
			i -= size
			if _, err := m.Metadata.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Provider != 0 {
		i = encodeVarintHistoryTree(dAtA, i, uint64(m.Provider))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceStorageRegionalMetadata_AwsS3Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceStorageRegionalMetadata_AwsS3Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsS3Metadata != nil {
		{
			size, err := m.AwsS3Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintHistoryTree(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *AWSS3Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSS3Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSS3Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssumeRoleArn) > 0 {
		i -= len(m.AssumeRoleArn)
		copy(dAtA[i:], m.AssumeRoleArn)
		i = encodeVarintHistoryTree(dAtA, i, uint64(len(m.AssumeRoleArn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintHistoryTree(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintHistoryTree(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintHistoryTree(dAtA []byte, offset int, v uint64) int {
	offset -= sovHistoryTree(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NamespaceStorageMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RegionalStorageMetadata) > 0 {
		for k, v := range m.RegionalStorageMetadata {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovHistoryTree(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovHistoryTree(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovHistoryTree(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NamespaceStorageRegionalMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Provider != 0 {
		n += 1 + sovHistoryTree(uint64(m.Provider))
	}
	if m.Metadata != nil {
		n += m.Metadata.Size()
	}
	return n
}

func (m *NamespaceStorageRegionalMetadata_AwsS3Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsS3Metadata != nil {
		l = m.AwsS3Metadata.Size()
		n += 1 + l + sovHistoryTree(uint64(l))
	}
	return n
}
func (m *AWSS3Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovHistoryTree(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovHistoryTree(uint64(l))
	}
	l = len(m.AssumeRoleArn)
	if l > 0 {
		n += 1 + l + sovHistoryTree(uint64(l))
	}
	return n
}

func sovHistoryTree(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHistoryTree(x uint64) (n int) {
	return sovHistoryTree(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NamespaceStorageMetadata) String() string {
	if this == nil {
		return "nil"
	}
	keysForRegionalStorageMetadata := make([]string, 0, len(this.RegionalStorageMetadata))
	for k, _ := range this.RegionalStorageMetadata {
		keysForRegionalStorageMetadata = append(keysForRegionalStorageMetadata, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRegionalStorageMetadata)
	mapStringForRegionalStorageMetadata := "map[string]*NamespaceStorageRegionalMetadata{"
	for _, k := range keysForRegionalStorageMetadata {
		mapStringForRegionalStorageMetadata += fmt.Sprintf("%v: %v,", k, this.RegionalStorageMetadata[k])
	}
	mapStringForRegionalStorageMetadata += "}"
	s := strings.Join([]string{`&NamespaceStorageMetadata{`,
		`RegionalStorageMetadata:` + mapStringForRegionalStorageMetadata + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceStorageRegionalMetadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceStorageRegionalMetadata{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceStorageRegionalMetadata_AwsS3Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceStorageRegionalMetadata_AwsS3Metadata{`,
		`AwsS3Metadata:` + strings.Replace(fmt.Sprintf("%v", this.AwsS3Metadata), "AWSS3Metadata", "AWSS3Metadata", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSS3Metadata) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSS3Metadata{`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`AssumeRoleArn:` + fmt.Sprintf("%v", this.AssumeRoleArn) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringHistoryTree(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NamespaceStorageMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHistoryTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceStorageMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceStorageMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionalStorageMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHistoryTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionalStorageMetadata == nil {
				m.RegionalStorageMetadata = make(map[string]*NamespaceStorageRegionalMetadata)
			}
			var mapkey string
			var mapvalue *NamespaceStorageRegionalMetadata
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHistoryTree
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHistoryTree
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthHistoryTree
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthHistoryTree
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHistoryTree
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthHistoryTree
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthHistoryTree
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamespaceStorageRegionalMetadata{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipHistoryTree(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthHistoryTree
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RegionalStorageMetadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHistoryTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceStorageRegionalMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHistoryTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceStorageRegionalMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceStorageRegionalMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			m.Provider = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Provider |= v1.StorageProvider(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsS3Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHistoryTree
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSS3Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Metadata = &NamespaceStorageRegionalMetadata_AwsS3Metadata{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHistoryTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSS3Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHistoryTree
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSS3Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSS3Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHistoryTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHistoryTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssumeRoleArn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHistoryTree
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssumeRoleArn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHistoryTree(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthHistoryTree
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHistoryTree(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHistoryTree
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHistoryTree
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHistoryTree
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHistoryTree
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHistoryTree
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHistoryTree        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHistoryTree          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHistoryTree = fmt.Errorf("proto: unexpected end of group")
)
